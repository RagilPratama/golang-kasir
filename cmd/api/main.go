package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"kasir-api/internal/config"
	"kasir-api/internal/handlers"
	"kasir-api/internal/repository"
	"kasir-api/internal/service"
	"log"
	"net/http"
	"os"

	_ "kasir-api/docs" // This will be generated by swag init

	_ "github.com/lib/pq"

	httpSwagger "github.com/swaggo/http-swagger"
)

// @title Kasir API
// @version 1.0
// @description API untuk aplikasi kasir sederhana
// @host golang-kasir-production.up.railway.app
// @Schemes https http
// @BasePath /api
func main() {
	// Load Config
	cfg, err := config.LoadConfig(".")
	if err != nil {
		log.Printf("Warning: cannot load config file, relying on environment variables: %v", err)
	}

	// Connect to DB
	db, err := sql.Open("postgres", cfg.DBUrl)
	if err != nil {
		log.Fatal("cannot connect to db:", err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		log.Fatal("cannot ping db:", err)
	}
	fmt.Println("Connected to Database!")

	// Create tables if not exist (Temporary solution for development)
	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS categories (
			id SERIAL PRIMARY KEY,
			name VARCHAR(255) NOT NULL,
			description TEXT
		);

		CREATE TABLE IF NOT EXISTS products (
			id SERIAL PRIMARY KEY,
			name VARCHAR(255) NOT NULL,
			price INT NOT NULL,
			stock INT NOT NULL
		);

		ALTER TABLE products ADD COLUMN IF NOT EXISTS category_id INT;
		
		DO $$ 
		BEGIN 
			IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_products_categories') THEN 
				ALTER TABLE products 
				ADD CONSTRAINT fk_products_categories 
				FOREIGN KEY (category_id) 
				REFERENCES categories(id); 
			END IF; 
		END $$;
	`)
	if err != nil {
		log.Fatal("cannot create tables:", err)
	}

	// Setup Routes
	// Root handler
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		response := map[string]string{
			"message": "Welcome to Kasir API",
			"status":  "running",
		}
		json.NewEncoder(w).Encode(response)
	})

	// Initialize Repository
	productRepo := repository.NewPostgresProductRepository(db)
	categoryRepo := repository.NewPostgresCategoryRepository(db)

	// Initialize Service
	productService := service.NewProductService(productRepo)
	categoryService := service.NewCategoryService(categoryRepo)

	// Initialize Handler
	productHandler := handlers.NewProductHandler(productService)
	categoryHandler := handlers.NewCategoryHandler(categoryService)
	// GET detail product
	// PUT update product
	http.HandleFunc("/api/product/", productHandler.HandleProductDetail)
	// GET product
	// POST product
	http.HandleFunc("/api/product", productHandler.HandleProductList)

	//Category
	http.HandleFunc("/api/category", categoryHandler.HandleCategoryList)
	http.HandleFunc("/api/category/", categoryHandler.HandleCategoryDetail)

	// Swagger
	http.HandleFunc("/swagger/", httpSwagger.WrapHandler)

	// Check for PORT env (Railway/Heroku)
	if port := os.Getenv("PORT"); port != "" {
		cfg.ServerAddress = ":" + port
	}

	fmt.Printf("server running di %s\n", cfg.ServerAddress)
	err = http.ListenAndServe(cfg.ServerAddress, nil)
	if err != nil {
		fmt.Printf("gagal running server: %v\n", err)
	}
}
